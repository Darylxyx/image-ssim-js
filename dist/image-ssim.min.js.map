{"version":3,"sources":["image-ssim.min.js","/source/image-ssim.min.js"],"names":["f","exports","module","define","g","window","global","ImageSSIM","self","this","s","require","u","n","a","o","t","i","code","Error","call","l","e","r","length",1,"compare","image2","K2","bitsPerComponent","lumaValues1","averageLumaValue2","sigsqx","image1","windowSize","K1","luminance","iteration","lumaValues2","averageLumaValue1","sigxy","sigsqy","Math","pow","numPixelsInWin","numerator","c1","c2","denominator","mssim","mcs","numWindows","width","height","L","Internals","_iterate","ssim","Channels","callback","y","x","windowWidth","min","windowHeight","_lumaValuesForWindow","averageLuma1","_averageLuma","averageLuma2","image","array","data","lumaValues","Float32Array","ArrayBuffer","counter","maxj","j","offset","channels","maxi","sumLuma"],"mappings":"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","file":"image-ssim.min.js","sourcesContent":["!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var r;r=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this,r.ImageSSIM=e()}}(function(){return function e(r,n,t){function o(a,f){if(!n[a]){if(!r[a]){var u=\"function\"==typeof require&&require;if(!f&&u)return u(a,!0);if(i)return i(a,!0);var h=new Error(\"Cannot find module '\"+a+\"'\");throw h.code=\"MODULE_NOT_FOUND\",h}var s=n[a]={exports:{}};r[a][0].call(s.exports,function(e){var n=r[a][1][e];return o(n?n:e)},s,s.exports,e,r,n,t)}return n[a].exports}for(var i=\"function\"==typeof require&&require,a=0;a<t.length;a++)o(t[a]);return o}({1:[function(e,r,n){var t;!function(e){\"use strict\";function r(e,r,t,o,i,a,f){function u(e,r,n,t){var o,i,a;o=i=a=0;for(var f=0;f<e.length;f++)i+=Math.pow(e[f]-n,2),a+=Math.pow(r[f]-t,2),o+=(e[f]-n)*(r[f]-t);var u=e.length-1;i/=u,a/=u,o/=u;var h=(2*n*t+s)*(2*o+c),v=(Math.pow(n,2)+Math.pow(t,2)+s)*(i+a+c);d+=h/v,p+=(2*o+c)/(i+a+c),l++}if(void 0===t&&(t=8),void 0===o&&(o=.01),void 0===i&&(i=.03),void 0===a&&(a=!0),void 0===f&&(f=8),e.width!==r.width||e.height!==r.height)throw new Error(\"Images have different sizes!\");var h=(1<<f)-1,s=Math.pow(o*h,2),c=Math.pow(i*h,2),l=0,d=0,p=0;return n._iterate(e,r,t,a,u),{ssim:d/l,mcs:p/l}}!function(e){e[e.Grey=1]=\"Grey\",e[e.GreyAlpha=2]=\"GreyAlpha\",e[e.RGB=3]=\"RGB\",e[e.RGBAlpha=4]=\"RGBAlpha\"}(e.Channels||(e.Channels={}));e.Channels;e.compare=r;var n;!function(e){function r(e,r,o,i,a){for(var f=e.width,u=e.height,h=0;u>h;h+=o)for(var s=0;f>s;s+=o){var c=Math.min(o,f-s),l=Math.min(o,u-h),d=n(e,s,h,c,l,i),p=n(r,s,h,c,l,i),v=t(d),w=t(p);a(d,p,v,w)}}function n(e,r,n,t,o,i){for(var a=e.data,f=new Float32Array(new ArrayBuffer(t*o*4)),u=0,h=n+o,s=n;h>s;s++){var c=s*e.width,l=(c+r)*e.channels,d=(c+r+t)*e.channels;switch(e.channels){case 1:for(;d>l;)f[u++]=a[l++];break;case 2:for(;d>l;)f[u++]=a[l++]*(a[l++]/255);break;case 3:if(i)for(;d>l;)f[u++]=.212655*a[l++]+.715158*a[l++]+.072187*a[l++];else for(;d>l;)f[u++]=a[l++]+a[l++]+a[l++];break;case 4:if(i)for(;d>l;)f[u++]=(.212655*a[l++]+.715158*a[l++]+.072187*a[l++])*(a[l++]/255);else for(;d>l;)f[u++]=(a[l++]+a[l++]+a[l++])*(a[l++]/255)}}return f}function t(e){for(var r=0,n=0;n<e.length;n++)r+=e[n];return r/e.length}e._iterate=r}(n||(n={}))}(t||(t={})),r.exports=t},{}]},{},[1])(1)});\n//# sourceMappingURL=image-ssim.min.js.map","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.ImageSSIM = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * @preserve\n * Copyright 2015 Igor Bezkrovny\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\n/**\n * - Original TypeScript implementation:\n *   https://github.com/igor-bezkrovny/image-quantization/blob/9f62764ac047c3e53accdf1d7e4e424b0ef2fb60/src/quality/ssim.ts\n * - Based on Java implementation: https://github.com/rhys-e/structural-similarity\n * - For more information see: http://en.wikipedia.org/wiki/Structural_similarity\n */\nvar ImageSSIM;\n(function (ImageSSIM) {\n    'use strict';\n    /**\n     * Grey = 1, GreyAlpha = 2, RGB = 3, RGBAlpha = 4\n     */\n    (function (Channels) {\n        Channels[Channels[\"Grey\"] = 1] = \"Grey\";\n        Channels[Channels[\"GreyAlpha\"] = 2] = \"GreyAlpha\";\n        Channels[Channels[\"RGB\"] = 3] = \"RGB\";\n        Channels[Channels[\"RGBAlpha\"] = 4] = \"RGBAlpha\";\n    })(ImageSSIM.Channels || (ImageSSIM.Channels = {}));\n    var Channels = ImageSSIM.Channels;\n    /**\n     * Entry point.\n     * @throws new Error('Images have different sizes!')\n     */\n    function compare(image1, image2, windowSize, K1, K2, luminance, bitsPerComponent) {\n        if (windowSize === void 0) { windowSize = 8; }\n        if (K1 === void 0) { K1 = 0.01; }\n        if (K2 === void 0) { K2 = 0.03; }\n        if (luminance === void 0) { luminance = true; }\n        if (bitsPerComponent === void 0) { bitsPerComponent = 8; }\n        if (image1.width !== image2.width || image1.height !== image2.height) {\n            throw new Error('Images have different sizes!');\n        }\n        /* tslint:disable:no-bitwise */\n        var L = (1 << bitsPerComponent) - 1;\n        /* tslint:enable:no-bitwise */\n        var c1 = Math.pow((K1 * L), 2), c2 = Math.pow((K2 * L), 2), numWindows = 0, mssim = 0.0;\n        var mcs = 0.0;\n        function iteration(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {\n            // calculate variance and covariance\n            var sigxy, sigsqx, sigsqy;\n            sigxy = sigsqx = sigsqy = 0.0;\n            for (var i = 0; i < lumaValues1.length; i++) {\n                sigsqx += Math.pow((lumaValues1[i] - averageLumaValue1), 2);\n                sigsqy += Math.pow((lumaValues2[i] - averageLumaValue2), 2);\n                sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\n            }\n            var numPixelsInWin = lumaValues1.length - 1;\n            sigsqx /= numPixelsInWin;\n            sigsqy /= numPixelsInWin;\n            sigxy /= numPixelsInWin;\n            // perform ssim calculation on window\n            var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n            var denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);\n            mssim += numerator / denominator;\n            mcs += (2 * sigxy + c2) / (sigsqx + sigsqy + c2);\n            numWindows++;\n        }\n        // calculate SSIM for each window\n        Internals._iterate(image1, image2, windowSize, luminance, iteration);\n        return { ssim: mssim / numWindows, mcs: mcs / numWindows };\n    }\n    ImageSSIM.compare = compare;\n    /**\n     * Internal functions.\n     */\n    var Internals;\n    (function (Internals) {\n        function _iterate(image1, image2, windowSize, luminance, callback) {\n            var width = image1.width, height = image1.height;\n            for (var y = 0; y < height; y += windowSize) {\n                for (var x = 0; x < width; x += windowSize) {\n                    // avoid out-of-width/height\n                    var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);\n                    var lumaValues1 = _lumaValuesForWindow(image1, x, y, windowWidth, windowHeight, luminance), lumaValues2 = _lumaValuesForWindow(image2, x, y, windowWidth, windowHeight, luminance), averageLuma1 = _averageLuma(lumaValues1), averageLuma2 = _averageLuma(lumaValues2);\n                    callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n                }\n            }\n        }\n        Internals._iterate = _iterate;\n        function _lumaValuesForWindow(image, x, y, width, height, luminance) {\n            var array = image.data, lumaValues = new Float32Array(new ArrayBuffer(width * height * 4)), counter = 0;\n            var maxj = y + height;\n            for (var j = y; j < maxj; j++) {\n                var offset = j * image.width;\n                var i = (offset + x) * image.channels;\n                var maxi = (offset + x + width) * image.channels;\n                switch (image.channels) {\n                    case 1 /* Grey */:\n                        while (i < maxi) {\n                            // (0.212655 +  0.715158 + 0.072187) === 1\n                            lumaValues[counter++] = array[i++];\n                        }\n                        break;\n                    case 2 /* GreyAlpha */:\n                        while (i < maxi) {\n                            lumaValues[counter++] = array[i++] * (array[i++] / 255);\n                        }\n                        break;\n                    case 3 /* RGB */:\n                        if (luminance) {\n                            while (i < maxi) {\n                                lumaValues[counter++] = (array[i++] * 0.212655 + array[i++] * 0.715158 + array[i++] * 0.072187);\n                            }\n                        }\n                        else {\n                            while (i < maxi) {\n                                lumaValues[counter++] = (array[i++] + array[i++] + array[i++]);\n                            }\n                        }\n                        break;\n                    case 4 /* RGBAlpha */:\n                        if (luminance) {\n                            while (i < maxi) {\n                                lumaValues[counter++] = (array[i++] * 0.212655 + array[i++] * 0.715158 + array[i++] * 0.072187) * (array[i++] / 255);\n                            }\n                        }\n                        else {\n                            while (i < maxi) {\n                                lumaValues[counter++] = (array[i++] + array[i++] + array[i++]) * (array[i++] / 255);\n                            }\n                        }\n                        break;\n                }\n            }\n            return lumaValues;\n        }\n        function _averageLuma(lumaValues) {\n            var sumLuma = 0.0;\n            for (var i = 0; i < lumaValues.length; i++) {\n                sumLuma += lumaValues[i];\n            }\n            return sumLuma / lumaValues.length;\n        }\n    })(Internals || (Internals = {}));\n})(ImageSSIM || (ImageSSIM = {}));\nmodule.exports = ImageSSIM;\n\n},{}]},{},[1])(1)\n});"],"sourceRoot":"/source/"}